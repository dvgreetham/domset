#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Sep 27 11:24:27 2018

@author: dvg27
"""



import csv
import math
import networkx as nx
import numpy as np

def sum_klouts(*args):
    if len(args)==1:
        nodes=args[0].nodes()
    elif len(args)==2:
        nodes=args[1]
    sum = 0
    for n in nodes:
        sum+=int(args[0].node[n]['weight'])

    return sum


def cost_fun(G, doms):
    cost_fun={}
    for node in G.nodes():
        if node in doms:
            s=1
        else: s=0
        sum_of_neighbors_weights=0
        for u in G.neighbors(node):
            sum_of_neighbors_weights=sum_of_neighbors_weights+G.node[u]['weight']
        cf=s*int(G.node[node]['weight'])/sum_of_neighbors_weights
       
        for u in G.neighbors(node):
            if u in doms:
                s=1
            else: s=0
            sum_of_neighbors_weights=0
            for w in G.neighbors(u):
                sum_of_neighbors_weights=sum_of_neighbors_weights+G.node[w]['weight']
            cf=cf+(1-s)*int(G.node[u]['weight'])/sum_of_neighbors_weights
        cost_fun[node]=cf
    return cost_fun

def is_dominated(G, doms, alpha):
    for u in G.nodes():    
        intersect = [ii for ii in doms if ii in G.neighbors(u)]                       
        rate=len(intersect)
        if rate < math.ceil(alpha*G.degree(u)):
            #print(rate, math.ceil(alpha*G.degree(u)))
            return False
    return True
for i in range(1):
    #f1="/Users/dvg27/Documents/Documents/Python27/graphs/list_random_partition_network_p_in0.02p_out0.0001/0_rp.graphml" 
    #print(f1)    
    alpha=0.5
    G=nx.read_gexf("lp3.gexf")
    for node in G.nodes():
        node_deg = G.degree(node)
        if node_deg < 1:
            print("Removing isolated nodes...")
            G.remove_node(node)
    #print(G.number_of_nodes(),G.number_of_edges())
    doms=[]
    costfun=cost_fun(G, doms)
    dominated=False
    while dominated==False:
        l=[u for u in G.nodes() if u not in doms]
        maxcf=0
        maxu=l[0]
        for u in l:
            if costfun[u]>maxcf:
               maxcf=costfun[u]
               maxu=u
               
        #print(maxu, maxcf, len(doms))
        doms.append(maxu)
        costfun=cost_fun(G, doms)
        if is_dominated(G, doms, alpha): 
            dominated=True
    print("Length of dominating set is", len(doms))
    print("Total sum of weights is", sum_klouts(G, doms))        
            